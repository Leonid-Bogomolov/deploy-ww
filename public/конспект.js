//_____________________________Введение, компоненты часть первая______________________________________________________

// REACT - библиотека для создания пользовательских инерфейсов, позволяет строить мастабируемые и динамичные веб-приложения с использованием комонентного подхода
// для установки чаще используется сборщик проектов VITE команды "npm create vite@latest", в заранее созданной папке, в которой будет создана ещё одна папка с самим приложением
// входе установки потребуется задать имя вновь создаваемой паки приложения, в списке библиотек выбрать React, в списке языков кода в нашем случае выбрали TypeScript
// нам требуется теперь переоткрыть VScode уже в папке с приложением
// появится ряд папок, в папке "public" находятся статичные файлы, например изображения или пояснения
// в папке «src» - ресурсы, т. е. весь исходный код приложения. В нем будет происходить основная часть работы
// в «eslintrc.cjs» - настройки «eslint»
// файл «gitignore» позволяет игнорировать файлы при добавлении на «github»
// в "index.html" - стандартный исходный  код HTML, в который будут встраиваться необходимые для работы приложения комппоненты создаваемого html-кода
// компонент это функция, которая возвращает разметку, названия компонентов начиаются с большой буквы
// корневым компоненом является "App", в него вызываются все осталные комоненты и именно App в итоге монтируется в «div id root» благодаря функции «create root» (см )
// В библиотеке React render — это метод, который определяет, что должно быть отображено на экране в ответ на изменение состояния или свойств компонента.
//           Он вызывается автоматически, когда компонент монтируется или обновляется
// для других компонентов в «src» создадим папку «components», чтобы не потерять компоненты в папке
// «package.json» определяет мета-информацию веб-приложения, загрузку библиотек, сборку проекта
// «README» описывает проект
// «tsconfig» - конфигурация для «TypeScript»
// «vit.config» - конфигурация для сборщика проекта

// ПРИ СБОРКЕ ПРОЕКТА ДОЛЖНА БЫТЬ ПАПКА «node_modules». Должны быть добавлены модули, поэтому в терминале напишем команду « npm i » или " npm init ";

// что бы запустить папку «node_modules» и, соответственно, приложение используем команду "npm run dev" (в «package.json» ей соответствует "dev" на которую можно навести мышкой), но
//           при использовании сборщика  «Create React App» вместо «Vite» используется команда «npm start»
// открывается локальный адрес «host:5173», если он свободен, либо какой-либо другой, по которому мы откроем приложение в браузере
// в данном учебном материале для сборки мнногостраничного сайта в качестве прототипа используется сайт: https://jelly-belly-wiki.netlify.app/

//______________________________________Компоненты часть вторая______________________________________________________

// в сайте-прототипе на странице "beans" открываем: devtools > Network > Fetch/XHR > кликаем по имени файла > Preview ; видим там массив объектов наших карточек "beams",
//  чтобы их скопировать переходим в раздел "Response" расположенный рядом с "Preview" и копируем всё, что там находится; создаём новую папку в src/data/beans.json
//  и вствляем скопированный файл
// импортируем  в App.tsx данные из beans.json (см App.tsx), видим, что всё загружается
// в components создаём паку Cards, в которой будем кодировать и стилизовать массив карточек и теперь импортировать данные из beans.json будем не в App.tsx, а в Cards/index.tsx
// видим, выводится много объектов, в которых много типов и которые надо описать, для этого создадим отдельную папку в "src" под названием "types" и в ней файл "bean.ts",
//  в которой и опишем типы  после того, как мы прописали типы свойств объекта в отдельной папке мы будем передавать их в виде объекта с названием data,
//  т.е. не прописывая отдельно каждое свойство в папке Card

//___________________________________События и изменение состояния, 1 часть__________________________________________

// Для демонстрации события создадим компонент "Counter" с кнопкой и временно отключим компоненте "Cards"
// События в JS можно добавлять тремя способами: во первых, в HTML при добавлении атрибутов onClick, onChange, submit и т.д.; во вторых, в JS обращаясь элементу "элемент.атрибут";
//  в третьих через событие прослушивание "addEventListener()" . В React используется первый способ 
//  (см: react-beans-конспект/3_события-изменение_состояния-1/src/components/Counter.imdex.tsx)

// подключив счётчик видим, что в консоле он работает, а на странице его начальное значение(состояние) не меняется
// Состояние – значение переменной, которое будет жить и работать внутри компонента.
// Хук – функция, которая может подцепиться к состоянию и методу жизненного цикла компонента.
// Отличие состояния от переменной в том, что когда состояние будет изменяться, компонент будет перерисовываться.
// Чтобы создать состояние используем хук «useState». Его нужно импортировать из библиотеки «react». Так как «useState» является функцией, то пишем круглые скобки.
//  Стоит почитать документацию про то как работает.
// «useState» возвращает массив из 2-х элементов. 1 – переменная, текущее значение. 2 – функция изменения состояния; объявим его
//  (см: react-beans-конспект/3_события-изменение_состояния-1/src/components/Counter.imdex.tsx)
// добавим ещё кнопку уменьшающее значение счётчика, теперь мы можем уменьшать или увеличивать количество товара к примеру
// можем продублировать этот компонент в App.tsx и тогда состояния полученных компонент будут не зависимыми и можно вести учёт отдельных товаров независимо друг от друга

//___________________________________События и изменение состояния, 2 часть__________________________________________

// Мы сегодня рассмотрим вариант, когда внутри одного компонента мы должны изменять состояние в зависимости от события в другом компоненте.
// Для этого нужно создать два компонента: первый отвечает за текст, а второй компонент отвечает за кнопки, где будут добавлены события.
// Создаем компонент под названием ‘Title’ и внутри этой папки создаем файл ‘index.tsx’, далее прописываем этот самый компонент
// Теперь создаем компонент под названием ‘Buttons’ и внутри этой папки ‘index.tsx’, далее описываем компонент
// вызовем оба созданных компонента в App.tsx; они на одном уровне вложенности и соседствуют друг с другом
// Когда мы начинали изучать данный модуль, было сказано, что одна из особенностей реакта – однонаправленный поток данных (когда мы данные передаем от родителя к дочернему компоненту).
// Это и есть такая ситуация, когда нам нужно завести состояние общего родителя и в один компонент передавать его значение, а в другой компонент передавать функцию его изменений
// Для этого в файле ‘App.tsx’ создаем состояние value и функцию состояния setValue и определим состояние value в Title в качестве атрибута (см App.tsx)
//  и начнём принимать его внутри компонента (Title/index.tsx)
// Сделаем аналогичнo для Title и Buttons, но имена атрибутов дадим разные для Title - data, для Buttons оставим value: передаем пропсы в компоненты 'Title' и ‘Buttons’ соответственно.
// У компонента Buttons будет два атрибута, т.к. в нём происходит изменение значения value, а значит ему требуется ещё передать ф-цию изменения состояния.
// разобрашись с пропсами и атрибутами и убедившись, что значения атрибутов компонента Buttons выводятся в консоль, нужно на кнопках описать событие и добавить обработчик события.

// Отличие от предыдущего случая (События и изменение состояния, 1 часть) в том, что в первом был один компонент, где мы изменяли сразу состояние и видели изменение при клике;
//  а в этом случае два разных компонента, при этом мы подняли состояние до родительского, то есть до ближайшего компонента, где встречаются два зависимых элемента.
//  Это называется поднять и определить значение до родительского состояния и передавать его в дочерний элемет.

// реакт запускает наше приложение в двух вариантах:
// первый это в строгом режиме;
// второй в нестрогом режиме, поэтому у нас дублируется вывод в консоли по два раза.
// Чтоы этого избежать заходим в файл ‘main.txs’ в котором App обернуто в тег <StrictMode>, что значит строгий режим, если удалить эту обёртку,
//  то компоненты при наступлении события будут рендерится (вызываться) только один раз

//______________________________________UseEffect-1 (props)___________________________________________________________________________

// Хуки – это особые функции из библиотеки React, которые позволяют «подключаться» к состоянию и функционалу компонентов.
//  Они упрощают работу с логикой жизненного цикла и заменяют классовые компоненты, делая разработку более гибкой и понятной.
// Когда мы говорим о жизненном цикле компонента, мы подразумеваем различные стадии, через которые проходит каждый React-компонент:
//   1) Монтирование – это момент, когда компонент появляется в DOM. И здесь часто требуется выполнить начальную настройку, например, сделать запрос к серверу или добавить подписки.
//   2) Обновление – происходит, когда изменяется состояние или пропсы компонента. Это фаза, когда можно обновить данные или выполнить повторную логику на основе новых значений.
//      props передаётся в компонент (служат как параметры функции(свойство))
//      «props» - объект, в котором есть ключ (название атрибута) в нашем случае "title" и то значение, которое мы ему присвоили "jelly Bob 1" 
//      FC — это сокращённый вариант интерфейса FunctionComponent. Он используется, чтобы указать TypeScript, что это функциональный компонент React, а не просто обычная функция.
//   3) Размонтирование – фаза, когда компонент удаляется из DOM. В этот момент важно выполнить «уборку»: отписаться от событий, остановить запросы и освободить ресурсы.
// До этого мы знали не функциональные компоненты, а классовые:
//   1) componentDidMount() — название классового метода, который вызывается, когда компонент монтируется в JavaScript
//   2) shouldComponentUpdate(). В этом методе сравнивают старые свойства или состояния с новым набором свойств или состояний. Можно указать, нужно ли заново отображать компонент,
//       вернув true или false
//   3) componentWillUnmount — название классового метода, который вызывается, когда компонент размонтируется в JavaScript
// В функциональных компонентах их заменяет хук UseEffect.
// Для начала создаем в папке components компонент ‘Example’ и начнем его описывать через файл ‘index.tsx’
// Встраиваем компонент в главный файл ‘App.tsx’ и проверяем результат на странице, заранее открывая консоль
// в Example/index.tsx начинаем использовать UseEffect
// Cоздаём состояние с именем ‘value’ и функцию для его изменения ‘setValue’( const [value, setValue] = useState(0) ), используя хук ‘useState’, задав начальное значение 0.
//  Затем заменим текст ‘Example’ на текущее значение состояния ‘{value}’. Добавим кнопку с текстом ‘Click’, которая при нажатии будет изменять наше состояние.
//  В событии ‘onClick’ опишем анонимную(стрелочнную) функцию, которая обновит состояние через ‘setValue(value + 1)’
// Видим, что при каждом клике по кнопке, хук ‘useEffect’ срабатывает при каждом изменении внутри компонента
//  добавим второй необязательный аргумент useEffect пустым и тогда ф-ция "effect" будет срабатывать только один раз при монтировании "Example",
//  если мы вторым аргуметом укажем имя какого-либо состояния объявленного в компоненте, например, ещё одной функциональной кнопкой,
//  то "effect" будет отрабатывть только при реализации события на ней (см components/Example/index.tsx)
// Отличие метода размонтироваия для useEffect заключается в присутствии в нём функции return (см components/Example/index.tsx), при срабатывании этого метода
//  компонент полностью удаляется из HTML кода и таким образом перересовывается не вся страница, а только часть кода

//____________________________________useEffect-2_______________________________________________________________________________

// Вернёмся к нашим бобам (картам).
// в реальных приложениях данные обычно приходят динамически, в зависимости от того, что присылает сервер через API.
// Для этого делаем запрос: напишем функцию ‘getData’ – это будет асинхронная функция, которая выполняет запрос
// Возвращаемся на сайт ‘jelly-belly-wiki’ и переходим по кнопке в ‘API Doc’. Здесь выбираем ‘Endpoints’ и получаем все товары, копируя ссылку.
//  Вставляем ее в кавычки (см components/Cards/index.tsx)

// если запрос упал, то нужно вывести ошибку для этого вводим ещё два бууленговых состояния, одно отвечает за запрос (isLoading), другое за ошибку (isError)

//____________________________________Управляемые и неуправляемые компоненты_____________________________________________________

// Создадим ещщё один компонент "Search (поиск)". Наша задача ввести в строку запрос (в ‘input’) и, нажимая на кнопку ‘найти’, отфильтровать текущие карточки.
// Нам нужно взять значение из ‘input’. Для этого мы можем добавить событие ‘onChange’ и написать обработчик событий ‘handleChange’
//  предварительно нужно описать событие через ‘const’ (см components/Search/index.tsx)
// Чтобы взять значение из input, добавим событие ‘onChange’ " <input type="text" onChange={handleChange} /> " и напишем обработчик событий ‘handleChange’ " const handleChange = () => {} "
// но нужно определить, что мы принимаем ‘event’ внутри нашего обработчика событий: " <input type="text" onChange={(event) => handleChange(event)} /> "
// чтобы вытащить введённое значение input из обработчика событий, создаём функцию состояния: " соnst [inputValue, setInputValue] = useState "
//  и вызываем его внутри обработчика событий ‘setInputValue(event.target.value)’
// чтобы фиксировать значения введённые в поле input, добавим тегу input атрибут value={inputValue}
// будем выводить значения в поле ввода по кнопке, для этого добавим кнопке обработчик событий onClick={handleClick} и создадим функцию события: " const handleClick = () => {} "
// в который будем обрабатывать функци состояния, например так: const handleClick = () => {alert(inputValue)}
// теперь чтобы производить фильтрацию карточек по значению в input, нужно перейти на уровень компонента Cards, т.е. в App и там создать
//  ф-цию состояния [filterValue, setFilterValue] = useState()
// Если мы удалим запрос, то в состоянии пустая строка, но наши исходные значения не перезаписались. Для решения нужно использовать оператор ‘else’: если у нас пустая строка
//  ‘filterValue’(поля ввода), тогда в обновленные данные записываем в начальные значения:  else {setUpdateBeans(initialBeans)}

//___________________________________UseContext____________________________________________________________________________________

// Возникают ситуации, когда нам нужно передавать значения внутри компонента от большего к меньшему, и цепочка оказывается достаточно большой.
//  Чтобы нам каждый раз не использовать пропсы, мы можем воспользоваться хуком useContext.
// Внутри родительского(App.tsx) компонента мы определим экспортируемую переменную, назовем ее ThemeContext, и используем функцию createContext из библиотеки React,
//  задав для начала значение "text"
// это объект, в котором есть различные ключи со значениями. Также здесь есть Provider, который как раз будет передавать некий контекст в группу наших компонентов.
// Нужно обернуть группу компонентов в этот контекст, чтобы мы могли внутри них спокойно его использовать. Обернем div с классом container в этот провайдер (см App.tsx)
// мы видим ошибку, что мы не передали свойство value. Когда мы используем провайдер, мы должны определить значение, которое хотим передать и изначально
//  у нас будет значение, допустим, light (светлая тема)
// Создадим компонент, назовем его SwitchTheme, данный компонент мы будем вызывать внутри вложенных частей (Header(Logo, Nav ); Search; Cards )
// Начнём с Nav (см components/Nav/index.tsx); в devTools видим, что внутри тега nav появился тег  <div>theme</div>, а на странице в меню "theme"
// Внутри компонента SwitchTheme нам нужно принимать текущий контекст; создадим там переменную, назовем ее currentTheme, присвоим ей useContext (см Switch/index.tsx) и
//  передаем ему ThemeContext
// Контекст у нас берется не из того, что мы определили в createContext(с начала мы там записали "text"), а из-за того, что мы передали ему значение value, поэтому логично,
//  когда мы создаем контекст, мы определяем начальное значение как null вместо "text", потому что у нас здесь уже передается его текущее значение "value" (см App.tsx),
//  а в угловых скобках указать тип: "export const ThemeContext = createContext<string | null>(null)".
// Теперь создадим внутри App состояние, назовем его theme, и будем передавать в провайдере под ключом value не строку,
//  а то, что у нас хранится внутри темы в виде объекта "{theme: theme, setTheme: setTheme}".

//____________________________________8_UseRef и порталы_________________________________________________________________________________

// UseRef представляет собой объект для хранения значений, которое может быть любым, и при его изменении значение будет сохраняться. Если значение изменится,
//  компонент не будет перерисован повторно.
// Рассмотрим пример, для этого создадим компонент <Example />, в котором будет элемент <p ref={pRef}>text</p>; внутри него будет атрибут "ref",
//  где pRef переменная объявленная внутри "Example" перед return равная хуку "useRef()"
// в консоле видим, что pRef - это объект с одним ключом "current", тождественным html-элементу "p" и который является объектом
// добавим кнопку в выводимый html-код, к ней событие и обработчик события (см component/Example/index.tsx) с командой "console.log(pRef.current)", т.е. pRef с ключом current,
//  видим, что при клике на кнопке выводится в консоль полный абзац параграфа "p", то что было в разметке. 
//  а при команде "console.dir(pRef.current?.textContent)" выведется только текст, если "console.dir(pRef.current?.focus())", то выведется ф-ция "focus" и т.д.;
//   т.е. работает так же, как дом элемент.
// Таким образом можем менять видимый контент на странице вызывая в нашем "Example" pRef.current c тем методом, который нам нужен, но
//   предварительно надо проверить на "null": " pRef.current.textContent = "Новое значение" " (см component/Example/index.tsx)

//______________________________________порталы; модальное окно____________________________________________________________________________

// Создаем компонент, который представлен в виде модального окна
// Хотим настроить модальное окно в нашей разметке, чтобы оно отображалось в какой-то ситуации. Если мы хотим полностью настроить элемент, как в доме,
//  мы рекомендуем использовать порталы, которые позволяют нам встроиться в иерархию DOM и добавлять любые элементы.
//  Для начала мы передаем значение, а также создаем состояние: [isModal, setIsModal] = useState(true) (см App.tsx) и пропсы. Но подумав перенесём подальше в Nav.
//  но не всегда он хорошо встраивается по тематике, и не всегда уместно добавлять модальное окно к Header.
//  Далее мы хотим изменять значение состояния и встраивать его в какую-либо часть HTML-страницы. Для этого нам нужно передать функцию изменения состояния в обработчик onClick,
//  причем она будет у нас функцией обратного вызова (callback), при вызове которой состояние будет изменяться на false
//  и передадим тип атриббута (тип: void - функция, которая ничего не возвращает) в пропс (см Modal.index.tsx);  таким образом, при клике на задний фон, она отработает.
// Теперь нам нужно встроить наш компонент modal именно в DOM. Мы создаем его с помощью порталов.                                                                                  
// В блоке return мы используем функцию createPortal, которая работает следующим образом: первым параметром она принимает разметку, а вторым — элемент,
//  куда нужно вставить эту разметку. В index.html мы добавим строку: <div id="modal"></div> .
// В компоненте Modal ещё добавим услоия на случаи, когда modalRoot не существует и когда modalRoot существует, т.е.
//  наше id существует или ннет (const modalRoot = document.getElementById("modal"))

//_______________________________________9_Пользовательские(кастомные) хуки____________________________________________________________________

// Хук - это функция, но в отличие от обычных функций, они могут возвращать состояние.
// Если это функции, значит, можем написать свои собственные; так научимся писать свои кастомные хуки.
// Чтобы хранить хуки в одном месте, мы в "src" создадим папку hooks.
// Для примера напишем хук, который будет отвечать за то, онлайн человек или нет; хуки начинаются с use, сответственно назовём его: " useOnlineStatus " .
// Соответственно файл в папке назовём " useOnlineStatus.ts "; .ts, а не .tsx - потому, что файл будет описывать только логику и возвращать значеие, а не возвращать html-разметку.
// ( описание и работу  см в src/hooks/useOnlineStatus.ts ).
// Далее вызовем хук в каком-либо компоненте, например в App.tsx; создадим переменную status и используем, как обычную функцию из библиотеки React 
// для проверки симулируем offline: devtools/Network/No_thrttling/Offline .
// Напишем для примера еще один хук, который будет определять ширину нашей страницы. Назовем хук useDeviceType.ts и поместим файл в папку hooks
// Для улучшения полученного хука используем "enum"

//______________________________________Ещё раз о хуках___________________________________________________________________________________________

// Хуки – это особые функции из библиотеки React, которые позволяют «подключаться» к состоянию и функционалу компонентов.
// Хук - это функция, но в отличие от обычных функций, они могут возвращать состояние.
//     Хуки упрощают работу с логикой жизненного цикла и заменяют классовые компоненты, делая разработку более гибкой и понятной.
//       Когда мы говорим о жизненном цикле компонента, мы подразумеваем различные стадии, через которые проходит каждый React-компонент:
//     1) Монтирование – это момент, когда компонент появляется в DOM. И здесь часто требуется выполнить начальную настройку, например, сделать запрос к серверу или добавить подписки.
//     2) Обновление – происходит, когда изменяется состояние или пропсы компонента. Это фаза, когда можно обновить данные или выполнить повторную логику на основе новых значений.
//          props передаётся в компонент (служат как параметры функции(свойство))
//          «props» - объект, в котором есть ключ (название атрибута) в нашем случае "title" и то значение, которое мы ему присвоили "jelly Bob 1" 
//          FC — это сокращённый вариант интерфейса FunctionComponent. Он используется, чтобы указать TypeScript, что это функциональный компонент React, а не просто обычная функция. 
//     3) Размонтирование – фаза, когда компонент удаляется из DOM. В этот момент важно выполнить «уборку»: отписаться от событий, остановить запросы и освободить ресурсы.

//  "useState" - нужен чтобы создавать и изменять состояние. Его нужно импортировать из библиотеки «react».
//         этот хук возвращает массив из 2-х элементов. 1 – переменная, текущее значение. 2 – функция изменения состояния; пример: const [isError, setIsError] = useState(true)

//  "useEffect" - нужен для монтирования, изменения и размонтирования React-компонентов 

//  "useContext" - используется при необходимости передачи значений от родителя к какому-то из дочерних и цепочка достаточно большая,
//         чтобы каждый раз не использовать пропсы, можем воспользоваться хуком useContext.

//  "useRef" - представляет собой объект для хранения значений, которое может быть любым, и при его изменении значение будет сохраняться. Если значение изменится,
//          компонент не будет перерисован повторно.

//  Пользовательские(кастомные) хуки - это хуки, которые разработчик пишет сам, как функции с использованием стандартных хуков из библиотеки React

//_____________________________________10_Роутинг, часть первая_________________________________________________________________________________________

// На начальный момент у нас всего лишь одна страница, контент которой определен внутри компонента app.tsx. И на какой бы страницу мы ни заходили, мы увидим все тот же самый контент.
// React поддерживает концепцию SPA – Single Page Application, когда у нас одна страница, но контент мы рисуем разный
// браузеру легче получить одну страницу и за счет логики перерисовать ее контент, нежели каждый раз делать запрос на получение новой html разметки.
// страница в данном случае – это некий компонент, функция, которая возвращает разметку.
// И первым делом создадим эти страницы. В scr создаем папку под названием pages. Первый файл будет называться Home.tsx и так для всех страниц: Btans, Facts и т.д.
// Нужно не только создать страницу, но и настроить. Настраивать мы будем с помощью библиотеки Reactor-Router-Dom.
// Добавим её к нам в проект. Для этого в терминале напишем команду "npm i react-router-dom" (см сайт npm).
// В src создадим файл под названием router.tsx; ".tsx" - потому что у нас будет возвращена разметка для каждой страницы.
// Создадим переменную под названием router и используем функцию из библиотеки react-router-dom – "const router = createBrowserRouter()"; далее см в router.tsx
// после этого переходим в App.tsx и пока очистим app - вынесем всё, что в return за пределы функции и закоммитим тремя налонными: ///, всё что касается вынесенного.
// С помощью тега <RouterProvide /> визуализируем то, что должно находиться на соответствующих страницах, но если путь прописан не правильно, то возникнет ошибка,
//      чтобы этого не происходило создадим ещё одну страницу NotFound в паке pages. Теперь при неправильном указании пути будет всплывать эта страеница с надписью "Not found".
// Приведём в порядок страницу Home, добавим анимационнную картинку, заголовок, текст, стилизуем её.
// Нужно сделать переходы между страницами. Добавим <Header /> на страницу (см Home.index.tsx) и у нас появилась шапка на странице.
// Чтобы навигатор стал кликабельным, нужно поправить написание ссылок. Когда мы используем библиотеку React-Router-DOM, мы уже не используем теги «a»,
//      мы используем тег link из библиотеки React-Router-DOM для перехода по странице 
// Будем добавлять таким же образом Header на всех страницах.
// Страницы будем добавлять через файл router.tsx
// Чтобы соэдать страницу Beans воспользуемся импортом из компоненты Cards, создадим на странице переменную "Beans", в которой создадим, как ранее в App.tsx функцию состояния
//       "const [filterValue, setFilterValue] = useState("")" и перенесём на эту страницу из App.tsx "<Search />"(Поиск) и "<Cards/>"(Карточки) с  атрибутами
//       "setFilterValue={setFilterValue}" и "filterValue={filterValue}" соответственно

//_____________________________________11_Роутинг, часть вторая_________________________________________________________________________________________

// Создадим страницу карточки одного товара: src/pages/Bean 
// в компонете Card, вместо тега <div> описывающего разметку одной карточки товара используем <Link> c отсылом к элемету BeanPage в "router.tsx": <Link to={`/bean/${data.beanId}`}>
// теперь в при клике на конкретную карточку на странице "Beans", данные этой карточки скопируются и получим номер карточки в том числе.   
// в router.tsx пишем адрес с указанием id(хотя обозвать можем как угодно, лишь бы понятно было о чём речь: beanId, name и т.д.) через ":", т.к. это значение переменное:
//  {path: "/bean/:id", element: <Bean />},
// Но как на странице одного товара взять текущий ID? Создадим переменную, назовем ее пока params и используем хук useParams из библиотеки ReactRouterDom (см pages/Bean/index.tsx)
// Params это объект, в котором есть различные ключи. Ключи определяются по названию того значения, которое мы передали. В route мы определили их как id, значит у нас создался ключ id,
//  но можем создавать не один ключ: path: "/bean/:id/:name/:text" и т.д.
//  Если компонент Bean отрисовывается, нужно сделать запрос на получение одного продукта, для этого нужно использовать хук useEffect и указать список зависимости – пустой массив
//  Для этого в useEffect прописываем  переменную getData в которой прописываем адрес до карточки с нужным id и укажем, что она асинхронная
// Создадим переменную req с ожиданием await и допишем функцию fetch с путем до карточки, переменная часть которой определяется номером конкретной карты ${params.id}
// вызываем функцию getData и проверим, что запрос ушёл: devtools/Network/( Fetch/XHR ), в Preview видим получаемые данные
// Ущё добавитм обработку нашего запроса с помощью конструкции try-catch. Если вдруг будет возникать ошибка, будем её отлавливать. Пока в консоли выведем Error
// После того как у нас произойдет запрос, что-то будет храниться в переменной req. Выведем это в консоль для проверки 
//  Данные пришли в качестве ответа, поэтому нам нужно их прочитать, для этого пишем советующую функцию: const data = await req.json()
// вызываем функцию по изменению состояния и заносим туда все, что мы распарсили: setBeanData(data) 
// Теперь можем сделать html-разметку, сделаем ещё условие – если beanData существует, то тогда мы уже рисуем div, указываем кллассы и п подставим ззначения из beanData
// ппрописываем css-стили

//___________________________________12_Layout (обёртка)____________________________________________________________________________________________________

// Можно наппрямую вставить Header и Footer на каждую страницу, а можно сделать обёртку для страниц
// Создадим в companents папку Layout, в которой и будет компонент Layout, который между тегами <Header /> и <Footer /> будет содержать <main><Outlet /></main>
// Где <Outlet /> - это специальный компонент, импортируемый из библиотеки React-Router-Dom, который понимает, что нам нужно встроить в блок "main" зависимости от маршрута
// теперь надо настроить маршруты с помощью функции "createBrowserRouter()", теперь router будет выглядеть по другому (см router.tsx), а также создадим
//  информационную функцию "Loader" для пользователей с собщением о перезагрузке страницы;
// суть в том, что загружается начальная страница вместе с Header и Footer, а потом будет перересовываться только содержимое страницы между <Header/> и <Footer/>

//___________________________________13_Формы часть 1___________________________________________________________________________________________________________

// Добавляем формы в веб-приложение с помощью библиотеки React.
// Создадим отдельную страницу и в папке “pages” создадим папку под названием “Review” (Рис. 1). В этой папке определим “index.tsx”, где опишем компонент под названием “Review”. 
// Чтобы собрать данные при событии при отправке формы добавляем события ни к самому тегу “button” либо “Input”, а к тегу формы. Событие называется “onSubmit”.
//  Напишем обработчик события “handleSubmit” и выше “return” опишем обработчик события "const handleSubmit"
//  проверяем срабатывание кнопки, видим, что срабатывает, но страница сразу же обновляется
//  предотвращение обновления страницы вложено в сам тег “form”, чтобы перезагружать страницу при отправке данных, нужно в “handleSubmit” принимать “event” с типом "formEvent".
// Импортируя тип из библиотеки React и указать, что тип элемента - “HTMLFormElement” далее нужно обратиться к “event” с использованием метода preventDefault
// Для того чтобы получить данные, понадобится конструктор, который описан в чистом JavaScript. Он называется “formData”.
// Создадим переменную "const form = new FormData(event.currentTarget)"; у event в React нет ключа target, используем currentTarget
// получим конструктор и нужно взять данные из конструктора с переменой и сформировать данные
// для получения даннных "data" обращаемся к глобальному объекту с ключом "fromEntries(form)": " const data = Object.fromEntries(form) "
// теперь получаем содержимое формы в виде объекта, где ключами являются атрибут input-ов "name".
// Также по данным элементам можно будет делать валидацию.
// Теперь можем даже без валидации создать асинхронную функцию, например: “postData”(запрос) используя функцию fetch, в которой укажем URL-адрес и какие-то общие настройки для
//  “POST” запроса
// отправив запрос, мы должны ответ как-то обрабатываем (const answer = await req.json()). И уже можем показывать пользователям наш ответ. К сожалению, тот API, который мы используем,
//  не предназначен для POST запросов. В качестве эксперимента мы можем использовать JSONPlaceholder, чтобы отследить, что наши запросы уходят.
// У нас появляется ошибка из-за того, что такой адрес не найден. Мы так же не можем делать запросы на наш локальный сервер,
//  потому что у нас нет локального сервера в приложении (React). React под это не предназначен.
// Если зайти на "JSONPlaceholder - Free Fake REST API", скопировать от туда POST запрос и вставить в наш код, То мы увидим, что запрос отправится.
//  Причём отправится не просто строка, а именно те данные, которые мы заполняли.
// Это самое простое использование тега “form”. Самое сложное тут - это описать данную форму, стилизовать, добавить атрибут “name” и потом с помощью конструктора “formData”
//  сформировать объект с данными из формы. После этого можно выполнять множество действий. Например: отправлять на сервер, валидировать, преобразовывать данные и работать с
//  ними в дальнейшем.

//__________________________________14 Формы часть 2___________________________________________________________________________________________________________

// Рассмотрим тему добавлеия форм, но с добавлением инструмента, который автоматизирует некоторые процессы, например валидацию и т.д..
// Инструмент называется ReactHook Form, необходимо зайти на сайт "https://www.react-hook-form.com/get-started/"и взять команду для добавления библиотеки: "npm install react-hook-form"
// немного очистим ранее написанный код, в "Review/index.tsx" уберем handleSubmit и само событие
// Первое, что нужно сделать, это взять функцию под названием Register из библиотеки.
// Для этого в const Review первым делом создаём: const {register, handleSubmit} = useForm(); Фигурные скобки — это деструктуризация, что именно хотим взять - хотим взять регистр
//  из hook useForm.
// Теперь не нужен атрибут "name" в инпутах, определять его будем с помощью данного инструмента, с помощью функции регистр
// вместо name="user_name" будет {...register("user_name")}, вообще говоря имя можем дать сами любое;
//  три точки означают ранее зарегистрированые поля, к которым добавляется еще какой-то новый элемент,
//  а в круглых скобках мы определяем уникальное название для этого input, здесь name в другом будет email и т.д.
// Но сейчас мы нигде не можем взять значение Register, нам нужно обработать данную форму.
// пишем событие, onSubmit; handleSubmit берем из hook.useform (см выше: const {register, handleSubmit}); handleSubmit - это всего лишь некая обертка,которая предотвращает перезагрузку
//  страницы, определяет каждое из полей и работает по своей функциональности, описанной внутри библиотеки
//  Также handleSubmit у нас принимает некую функцию, которую нужо создать; то есть нам осталось описать нужную логику.
//  Давайте функцию, описывающую логику, назовем, особо не фантазируя, так же, как и событие, onSubmit. Название функции может быть любое, а перед return опишем функцию onSubmit
//  безымянной стрелочной функцией, в консоли пока выведем какое-нибудь значение (см Review.index.tsx) отправив форму видим, что событие сработало.
// если в безымянной стрелочной функции передадим аргумент data: const onSubmit = (data) => {console.log(data)} и выведем в консоль, то выводятся поля, которые мы указали в
//  инпутах в register
// теперь нужно описать типы для каждого из элементов формы, перед объявлением const Review пропишем type FormType
// типы нужно привязать к submit, но не описываем где-то, onSubmit, а нужно именно для хука «UseForm» определить типизацию. Здесь описываем,
//  что «Use Form у нас будет типа formType: useForm<FormType>().
// Для типизации data, нужно прописать типизацию внутри функцию onSubmit, простое наведение на имя функции не даёт подсказки, т.к. в документации указано,
//  что внутри библиотеки есть такой тип, как SubmitHandler
// Его мы импортируем из библиотеки React.hook.form и через него передаем тот тип, который был описан ранее: const onSubmit: SubmitHandler<FormType> = (data) => {...}
// То есть два раза типизируем: сам hook useForm, и обработчик события, onSubmit. И теперь дата типизирована, можем работать с ней как захотим
// Зарегистрируем еще некоторые поля, например, возможен select (выбор) из нескольких и значит ещё должен быть optin, добавим select с optin внутри в форму
// добавляем к select в качестве арибута регистр, раскладываем ранее все определенные значения и добавляем новое: {...register("category")}, добавим ещё один тип - category в type
// Для валидации есть встроенная в библиотеку валидация: дополнительно через запятую можем добавить необязательные атрибуты, например добавить "required" - "обязательное поле"
//  и сработает валидация, форма отправлена не будет.
//  Для ошибок можно вывести подсказки, для этого нам нужно опять обратиться к хуку useForm и взять такой ключ как formState где мы берем только ошибки:
//  "const {register, handleSubmit, formState: {errors}} = useForm<FormType>()" и внутри соответствующего label и после input вставляем логическое условие для
//  вывода сообщения: "{errors.user_email && <p className={style.errors}>{errors.user_email.message}</p>}"
 